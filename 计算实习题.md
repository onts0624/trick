# 计算实习题

1. 自选一幅原始图像，并选择一幅水印信息（内含自己的学号和英文姓名），将水印信号嵌入原始信号，分别取水印强度$\alpha=1.0, 0.5, 0.2$三种情况
2. 利用SVD数字水印加密、数字水印解密
3. 写出实验报告，包括：问题简单描述，算法流程，变量说明，程序清单，输出计算结果，结果分析和小结等
4. 实验报告在6月5日前发送到邮箱 jxzhaonju@sina.com，邮件主题和实验报告开头都要标注学号和姓名



## 实验报告

学号：MG1733063

姓名：汪然

### 问题简单描述

在多媒体中加入数字水印可以帮助版权所有者的权利，同时认证数据来源的可靠性，其在篡改鉴定、数据分级访问、数据跟踪和检测等场景都有着广阔的应用场景。

本次实验将实现一个以SVD为理论基础的水印程序，包括水印嵌入算法、水印提取和验证算法两部分。

### 算法流程

下面分别阐述水印嵌入算法及水印提取和验证算法。

**水印嵌入算法**：

记$A$为原始图片，$W$为水印图片，$\alpha$为水印强度参数，将按照以下方式构造水印图像$A_w$：
$$
\left\{
\begin{array}{lr}
A \Rightarrow USV^T\\
L \Leftarrow S+\alpha W\\
L \Rightarrow U_1S_1V_1^T\\
A_w\Leftarrow US_1V^T
\end{array}
\right.
$$
如此，将得到含有水印的图片$A_w$，还需要保存嵌入过程中的$U_1, V_1, \alpha, S$以待后期提取水印所用.



**水印提取和验证算法**：

记$P$为待检测图像，嵌入过程如下：
$$
\left\{
\begin{array}{lr}
P\Rightarrow U_pS_pV_p^T\\
F\Leftarrow U_1 S_pV_1^T\\
W_E\Leftarrow (F-S)/\alpha
\end{array}
\right .
$$
通过计算$W$和$W_E$的相关度可以评判水印是否存在.



### 变量说明及程序清单

与算法对应的有两份代码，编入水印的代码`encode.m`如下：

**变量说明**：$A$为原图，$W$为水印，$\alpha$为水印强度

```matlab
function [ ] = encode( img, watermark, alpha, output)
%ENCODE SVD水印嵌入算法
%   img: 原图路径
%   watermark: 水印路径
%   alpha: 水印强度
%   output: 输出图片路径

% 读入原图片A
A = imread(img);
if (ndims(A) == 3)
   A = rgb2gray(A); % 灰度化 
end
A = double(A) ./ 255; % 归一化，否则显示不正常
% imshow(A);

% 读入水印
W = imread(watermark);
if (ndims(W) == 3)
    W = rgb2gray(W); % 灰度化
end
W = double(W) ./ 255; % 归一化，否则显示不正常
% imshow(W);

% 加密
% step1: A => USV^T
[U,S,V] = svd(A);
% step2: L <= S + alpha * W
% alpha = 0.15;
L = S + alpha .* W;
% step3: L => U1 S1 V1^T
[U1,S1,V1] = svd(L);
% step4: Aw <= U S1 V^T
Aw = U*S1*V';
% imshow(Aw);
imwrite(Aw, output);
save([output, '.mat'], 'U1', 'V1', 'alpha', 'S');
end
```



提取并验证水印的代码`decode.m`如下：

**变量说明**：$P$为待检测图片，$U_1$，$V_1$为调用上述`encode.m`时对$L$进行SVD的两个矩阵，$S$为对$A$进行SVD分解的矩阵，$\alpha$为水印强度.

```matlab
function [ ] = decode( img, output )
%DECODE SVD水印提取验证算法
%   img: 添加水印后的图片路径
%   output: 提取水印的保存路径

% 读入添加水印后的图片
P = imread(img);
if (ndims(P) == 3)
    P = rgb2gray(P); % 灰度化
end
P = double(P) ./ 255; % 归一化
% imshow(A);

% step1: P => Up Sp Vp^T
[Up,Sp,Vp]=svd(P);
% 加载重要变量U1,V1,alpha,S
load([img, '.mat'], 'U1', 'V1', 'alpha', 'S');
% step2: F <= U1 Sp V1^T
F = U1*Sp*V1';
% step3: We <= (F-S) ./alpha
We = (F-S)./alpha;
imwrite(We, output);
end
```



### 输出计算结果

分别运行如下命令，得到加入水印后的图片及对应提取出的水印图片：

```matlab
% alpha = 1.0
encode('a.jpg', 'w.jpg', 1.0, '1.0aw.jpg'); decode('1.0aw.jpg', '1.0w.jpg');
% alpha = 0.5
encode('a.jpg', 'w.jpg', 0.5, '0.5aw.jpg'); decode('0.5aw.jpg', '0.5w.jpg');
% alpha = 0.2
encode('a.jpg', 'w.jpg', 0.2, '0.2aw.jpg'); decode('0.2aw.jpg', '0.2w.jpg');
```



### 结果分析

下面对插入水印及提取的水印进行分析，先给出原图及水印标志：

![raw](G:\workspace\matlab\svd\raw.jpg)

**$\alpha=1.0$**

![1.0w](G:\workspace\matlab\svd\1.0.jpg)

**$\alpha=0.5$**

![1.0w](G:\workspace\matlab\svd\0.5.jpg)

**$\alpha=0.2$**

![0.2](G:\workspace\matlab\svd\0.2.jpg)



从图中可以看到，随着$\alpha$的增大，对原图的破坏越大（指与未加入水印的图片相比，视觉差异大）；而$\alpha=1.0, 0.5, 0.2$时对于水印的提取影响并不大，都可以清晰的看到相关信息。

### 小结

本次实验以数字水印为应用场景，将SVD应用于其中，可以感受到科学与技术的紧密联系，见证科学的美妙之处。但在实践SVD数字水印的过程中，也可以看到该技术的如下缺陷：

1. 计算量大。当前工作只是对于静态图片进行的插入水印操作，但当该技术应用于视频等数字产品时，每次都要进行繁重的矩阵计算，并不适宜。
2. 对数字产品有所损坏。虽然$\alpha$可以控制水印的强度，但可以看到即便$\alpha=0.2$时也会对加入水印的图片产生明显的影响。可能的改良方式是，一是缩小打水印的区域，二是尝试更小的水印强度。



